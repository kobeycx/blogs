---
  layout: default
  title: 理解 RunLoop
---

<div class="row">
  <div class="col-md-8" style="border-right:1px solid rgba(0, 0, 0, 0.1);">
    <h2>{{ page.title }}</h2>
    <a href="https://blog.ibireme.com/2015/05/18/runloop" class="text-muted small">原文作者 ibireme (https://blog.ibireme.com/2015/05/18/runloop)</a>
    <hr>

    <h3 id="base">RunLoop 的概念</h3>
    <p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的:</p>
    <div class="card">
      <div class="card-body code-block">
        <span class="item text-muted">function loop() {</span>
        <span class="item text-muted">&nbsp;&nbsp;&nbsp;&nbsp;initialize()</span>
        <span class="item text-muted">&nbsp;&nbsp;&nbsp;&nbsp;do {</span>
        <span class="item text-muted">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var message = get_next_message();</span>
        <span class="item text-muted">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_message(message);</span>
        <span class="item text-muted">&nbsp;&nbsp;&nbsp;&nbsp;} while (message != quit);</span>
        <span class="item text-muted">}</span>
      </div>
    </div>

    <p>实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
    <p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息->等待->处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
    <p>
      <div>iOS 系统中，提供了两个这样的对象：<strong>NSRunLoop</strong> 和 <strong>CFRunLoopRef</strong>。</div>
      <div><strong>CFRunLoopRef</strong> 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</div>
      <div><strong>NSRunLoop</strong> 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</div>
    </p>
    <hr>

    <h3 id="thread">RunLoop 与线程的关系</h3>
    <p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>
    <p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：<strong>CFRunLoopGetMain()</strong> 和 <strong>CFRunLoopGetCurrent()</strong>。</p>
    <p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
    <hr>

    <h3 id="api">RunLoop 对外的接口</h3>
    <p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
    <p>CFRunLoopRef</p>
    <p>CFRunLoopModeRef</p>
    <p>CFRunLoopSourceRef</p>
    <p>CFRunLoopTimerRef</p>
    <p>CFRunLoopObserverRef</p>

    <p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>
    <img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" width="30%;">
    <p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
    <p>
      <div><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</div>
      <div>• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</div>
      <div>• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</div>
    </p>
    <p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
    <p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
    <div class="card code-block">
      <div class="card-body">
        <span class="item text-muted">kCFRunLoopEntry (即将进入Loop)</span>
        <span class="item text-muted">kCFRunLoopBeforeTimers (即将处理 Timer)</span>
        <span class="item text-muted">kCFRunLoopBeforeSources (即将处理 Source)</span>
        <span class="item text-muted">kCFRunLoopBeforeWaiting (即将进入休眠)</span>
        <span class="item text-muted">kCFRunLoopAfterWaiting (刚从休眠中唤醒)</span>
        <span class="item text-muted">kCFRunLoopExit (即将退出Loop)</span>
      </div>
    </div>
    <p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
  </div>
  <div class="col-md-4">
    <ul>
      <li><a href="#base">RunLoop 的概念</a></li>
      <li><a href="#thread">RunLoop 与线程的关系</a></li>
      <li><a href="#api">RunLoop 对外的接口</a></li>
    </ul>
  </div>
</div>
